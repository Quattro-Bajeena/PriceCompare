Algorytm zachÂªanny Greedy
Zaimplementowanie prostego algorytmu zachÂªannego jest dobrym sposobem na
bardzo szybkie rozwiÂ¡zanie problemÃ³w NP-trudnych i w ogÃ³lnoÂ±ci moÂ»e zapew-
niÂ¢ dobrÂ¡ jakoÂ±Â¢ rozwiÂ¡zaÂ« poprzez zapewnienie lokalnie optymalnych rozwiÂ¡zaÂ«
na kaÂ»dym etapie algorytmu. Dlatego teÂ» postanowiliÂ±my przygotowaÂ¢ prosty al-
gorytm zachÂªanny dedykowany dla problemu ISOP. GÂªÃ³wnym celem byÂªo opra-
cowanie metody, ktÃ³ry moÂ»e dziaÂªaÂ¢ szybko i zapewnia lepsze wyniki niÂ» algo-
rytmy znane ze stron porÃ³wnujÂ¡cych ceny. Zestawienie wynikÃ³w eksperymentÃ³w
obliczeniowych dla algorytmÃ³w porÃ³wnywarek cen (w dwÃ³ch rÃ³Â»nych wersjach)
znajduje siÂ¦ w rozdziale 6 pracy Wojciechowskiego i MusiaÂªa [106].
W dalszej czÂ¦Â±ci zamieszczono pseudokod algorytmu zachÂªannego obrazujÂ¡cy
zasadÂ¦ jego dziaÂªania (patrz algorytm 6). W celu uzyskania lepszych rezultatÃ³w
algorytm moÂ»e byÂ¢ uruchomiony wielokrotnie dla rÃ³Â»nych kolejnoÂ±ci produktÃ³w
na liÂ±cie N , np. recn < recnâˆ’1 < rec1, lub losowo recn?recnâˆ’1?rec1, gdzie ?
oznacza dowolnÂ¡ relacjÂ¦.
Zaobserwowano, Â»e algorytm zachÂªanny Greedy prezentuje dobrÂ¡ wydajnoÂ±Â¢
i jakoÂ±Â¢ uzyskiwanych wynikÃ³w. Niemniej jednak, w bardzo specycznych sytu-
acjach (mimo, Â»e niezwykle nierealnych) moÂ»e prowadziÂ¢ do osiÂ¡gniÂ¦cia wyniku
wielokrotnie gorszego od optimum. NiniejszÂ¡ sytuacjÂ¦ obrazuje tabela 4.4.
MoÂ»na Âªatwo zauwaÂ»yÂ¢, Â»e dla dowolnej kolejnoÂ±ci startowej produktÃ³w (se-
kwencja) wszystkie zostanÂ¡ zakupione w sklepie 1 z ÂªÂ¡cznym kosztem n âˆ— W .
Optymalne natomiast bÂ¦dzie rozwiÂ¡zanie, w ktÃ³rym wszystkie produkty zo-
staÂªy zakupione w dowolnym sklepie innym niÂ» 1, a ÂªÂ¡czny koszt wynosi W + .
Pierwszy krok algorytmu heurystycznego powoduje jego skazÂ¦ i stÂ¡d pÃ³Â¹niej-
sza zmiana na inny sklep dla kaÂ»dego lokalnego kroku wydaje siÂ¦ nieopÂªacalna.
RozdziaÂª 4. Problem optymalizacji zakupÃ³w internetowych 73
Algorytm 6 ZachÂªanny dla ISOP
Pseudokod obrazujÂ¡cy dziaÂªanie algorytmu zachÂªannego, ktÃ³ry dziaÂªa po-
przez wyznaczanie rozwiÂ¡zaÂ« lokalnie optymalnych.
Require:
N = {1, . . . , n}  produkty do kupienia
M = {1, . . . , m}  sklepy
pij  cena produktu j w sklepie i
recj  rekomendowana cena sprzedaÂ»y produktu j
di  koszt dostawy dla sklepu i
dsi = di  koszt dostawy uÂ»ywany do nalnej kalkulacji
sum = 0  ÂªÂ¡czna cena zakupÃ³w
âˆ€jâˆˆN Rj = 0  wskaÂ¹nik wyboru (lista realizacji), dla kaÂ»dego produktu j
1: Ustaw kolejnoÂ±Â¢ produktÃ³w 1, . . . , n gdzie recn â‰¥ recnâˆ’1 â‰¥ rec1
2: Wybierz pierwszy produkt j = 1
3: while doj < n
4: Wybierz sklep i dla produktu j tak, Â»e min(fi(pij ) + di); i = 1, . . . , m
5: Rj = i. di = 0
6: Wybierz kolejny produkt j = j + 1
7: end while
8: S = âˆ‘M
i=1 fi(P ) + dsi : di 6 = 0
9: return S,R
Pozostanie przy sklepie 1 prowadzi do bardzo niekorzystnego wyniku.
W celu zabezpieczenia przed podobnymi przypadkami opracowaliÂ±my kolejny
algorytm heurystyczny, oznaczony jako Forecasting.